NAMESPACE Global
FUNCTION_BLOCK FB_MABS
{ S7_Optimized_Access := 'TRUE' ; Published := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      MABS_ID : Int;
      CrossSensor : Bool;
      Fault : Bool;
      UpstreamRunning : Bool;
      Downstream_Straight : Bool;
      "Downstream_Right/Left" : Bool;
      SortDir : ItemDir;
      ManIn : MABS_ManIn;
      Setpoints : MABS_Setpoint;
   END_VAR

   VAR_IN_OUT 
      MABS_IBP_in : _."IB_P01/02/03_in_64bytes_struct";
      MABS_IBP_out : _."IB_P01/02/03_out_64bytes_struct";
   END_VAR

   VAR 
      ReadInputSignal : Struct
         CrossSensor : Bool;
         EmergencyStop : Bool;
         Fault : Bool;
      END_STRUCT;
      Active : Struct
         Line : Struct
            A1 : Bool;
            B1 : Bool;
            C1 : Bool;
            D1 : Bool;
         END_STRUCT;
      END_STRUCT;
      CROSS_SENSOR_FILTER : FB_Sensor;
      MABS_SENSOR_BLOCKAGE {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;
      MABS_STATUS_ON : FB_StatusON;
      MABS_STATUS_READY : FB_StatusReady;
      MABS_STATUS_FAULT : FB_StatusFault;
      AUTO_RESET : FB_AutoReset;
      MABS_CONTROL : FB_MABS_PNIO;
      SSR : SystemSSR;
      ReadMabsStatus : ConveyorStatus;
      ReadMabsParameter : ConveyorParameters := ((), [2(T#10ms)], (), (), ());
      MABSFault : Fault;
      SimuMode : Struct
         Sensor : Bool;
         Fault : Bool;
      END_STRUCT;
      StartUpTimer {InstructionName := 'TOF_TIME'; LibVersion := '1.0'; S7_SetPoint := 'False'} : TOF_TIME;
      FT_StartUp {InstructionName := 'F_TRIG'; LibVersion := '1.0'} : F_TRIG;
      SetStartUp { S7_SetPoint := 'True'} : Bool;
      VisuColor : Word;
      PhaseError : Bool;
      StartupMABS { S7_SetPoint := 'True'} : Bool;
      FilteredSensor { S7_SetPoint := 'True'} : Bool;
      AutoReset { S7_SetPoint := 'True'} : Bool;
      StopSystemFireActive : Bool;
      Sort { S7_SetPoint := 'False'} : ItemDir;
      Home : Bool;
      HomeCheckTimer {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;
      CurrentPosition : Struct
         left : Bool;
         right : Bool;
         straight : Bool;
      END_STRUCT;
      "Cmd+Setpoint" { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : MABS;
   END_VAR


BEGIN
	// ==========================================================================================================================================
	// Company        : LogTech, s.r.o.
	// Created by     : Anton Vinoth Soundraraj
	// Block          : FB_MABS
	// Project        : Lékarna DC Chrudim
	// Project number : 23-157
	// ==========================================================================================================================================
	
	REGION Active Line
	    
	    // Line A1
	    IF (#MABS_ID >= _.gMinA1 AND
	        #MABS_ID <= _.gMaxA1)
	    THEN
	        #Active.Line.A1 := TRUE;
	    END_IF;
	    
	    // Line B1
	    IF (#MABS_ID >= _.gMinB1 AND
	        #MABS_ID <= _.gMaxB1)
	    THEN
	        #Active.Line.B1 := TRUE;
	    END_IF;
	    
	    // Line C1
	    IF (#MABS_ID >= _.gMinC1 AND
	        #MABS_ID <= _.gMaxC1)
	    THEN
	        #Active.Line.C1 := TRUE;
	    END_IF;
	    
	    // Line D1
	    IF (#MABS_ID >= _.gMinD1 AND
	        #MABS_ID <= _.gMaxD1)
	    THEN
	        #Active.Line.A1 := TRUE;
	    END_IF;
	    
	END_REGION
	
	REGION SystemSSR
	    
	    // Line A1
	    IF #Active.Line.A1 THEN
	        #SSR.StartSystem := DB_SystemSSR.Line.A1.StartSystem;
	        #SSR.StopSystem := DB_SystemSSR.Line.A1.StopSystem;
	        #SSR.ResetSystem := DB_SystemSSR.Line.A1.ResetSystem;
	    END_IF;
	    
	    // Line B1
	    IF #Active.Line.B1 THEN
	        #SSR.StartSystem := DB_SystemSSR.Line.B1.StartSystem;
	        #SSR.StopSystem := DB_SystemSSR.Line.B1.StopSystem;
	        #SSR.ResetSystem := DB_SystemSSR.Line.B1.ResetSystem;
	    END_IF;
	    
	    // Line C1
	    IF #Active.Line.C1 THEN
	        #SSR.StartSystem := DB_SystemSSR.Line.C1.StartSystem;
	        #SSR.StopSystem := DB_SystemSSR.Line.C1.StopSystem;
	        #SSR.ResetSystem := DB_SystemSSR.Line.C1.ResetSystem;
	    END_IF;
	    
	    // Line D1
	    IF #Active.Line.D1 THEN
	        #SSR.StartSystem := DB_SystemSSR.Line.D1.StartSystem;
	        #SSR.StopSystem := DB_SystemSSR.Line.D1.StopSystem;
	        #SSR.ResetSystem := DB_SystemSSR.Line.D1.ResetSystem;
	    END_IF;
	    
	END_REGION
	
	REGION Read Input
	    
	    // read all inputs to the block
	    // Conveyor input read signals
	    #ReadInputSignal.CrossSensor := NOT #CrossSensor OR
	    #SimuMode.Sensor; // simu call
	    #ReadInputSignal.Fault := #Fault OR
	    #SimuMode.Fault; // simu call;
	    #ReadInputSignal.EmergencyStop := // all estop zones are connected together
	    _.DB_SafetyStandard.ToStandard.EstopActive;
	    
	END_REGION
	
	REGION READ AND INIT
	    
	    REGION parameters
	        
	        // Line A1
	        IF #Active.Line.A1 THEN
	            #ReadMabsParameter := DB_ConveyorParameters.Line.A1.Conveyor[#MABS_ID];
	        END_IF;
	        // Line B1
	        IF #Active.Line.B1 THEN
	            #ReadMabsParameter := DB_ConveyorParameters.Line.B1.Conveyor[#MABS_ID];
	        END_IF;
	        // Line C1
	        IF #Active.Line.C1 THEN
	            #ReadMabsParameter := DB_ConveyorParameters.Line.C1.Conveyor[#MABS_ID];
	        END_IF;
	        // Line C1
	        IF #Active.Line.D1 THEN
	            #ReadMabsParameter := DB_ConveyorParameters.Line.D1.Conveyor[#MABS_ID];
	        END_IF;
	        
	    END_REGION
	    
	    REGION FIRE
	        
	        // Fire signal from fire system stops the whole system
	        // System can be reset from Fire status only if the fire signal is deactivated
	        
	        // FIRE ALARM ACTIVE --> STOP SYSTEM
	        IF DB_SystemSimu.Fire THEN
	            #StopSystemFireActive := TRUE;
	        END_IF;
	        // RESET --> FIRE ALARM
	        IF #SSR.ResetSystem AND NOT DB_SystemSimu.Fire THEN
	            #StopSystemFireActive := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION Conveyor startup
	    
	    // Conveyor StartUp: Conveyor startup signal after 5 second delay
	    
	    #StartUpTimer.TOF(IN := #SSR.StartSystem,
	                      PT := #ReadMabsParameter.StartUpTime);
	    
	    #FT_StartUp(CLK := #StartUpTimer.Q);
	    
	    // set startup after 5 seconds
	    #SetStartUp := #FT_StartUp.Q;
	    
	END_REGION
	
	REGION Conveyor Status
	    
	    REGION Status ON
	        
	        // ----------------------------------------->>>>>>> STATUS ON <<<<<<<-----------------------------------------
	        // FB_ConveyorStatusON
	        // called as IDMB
	        
	        #MABS_STATUS_ON(SystemStartActive := #SSR.StartSystem,
	                        StatusStop := #ReadMabsStatus.Stop,
	                        StatusEStop := #ReadMabsStatus.Estop,
	                        StatusManual := #ReadMabsStatus.Manual,
	                        StatusFault := #ReadMabsStatus.Fault,
	                        FireAlarmActive := #StopSystemFireActive,
	                        StatusON => #ReadMabsStatus.ON);
	        
	    END_REGION
	    
	    REGION Status Ready
	        
	        // ----------------------------------------->>>>>>> STATUS READY <<<<<<<-----------------------------------------
	        // FB_ConveyorStatusReady
	        // called as MIDB
	        
	        #MABS_STATUS_READY(StatusON := #ReadMabsStatus.ON,
	                           StatusESTOP := #ReadMabsStatus.Estop,
	                           StatusFAULT := #ReadMabsStatus.Fault,
	                           StatusMAN := #ReadMabsStatus.Manual,
	                           SignalFIRE := #StopSystemFireActive,
	                           SystemAlertTime := #ReadMabsParameter.StartUpTime,
	                           StatusReady => #ReadMabsStatus.ReadytoRun);
	        
	    END_REGION
	    
	    REGION Status Occupied
	        
	        // ----------------------------------------->>>>>>> STATUS OCCUPIED <<<<<<<-----------------------------------------
	        
	        #ReadMabsStatus.Occupied :=
	        #CROSS_SENSOR_FILTER.FilteredSensor;
	        
	    END_REGION
	    
	    REGION Status Running
	        
	        // ----------------------------------------->>>>>>> STATUS RUNNING <<<<<<<-----------------------------------------
	        
	        #ReadMabsStatus.Running :=
	        #ReadMabsStatus.ReadytoRun AND
	        #"Cmd+Setpoint".Run_balls;
	        
	    END_REGION
	    
	    REGION Status Fault
	        
	        // ----------------------------------------->>>>>>> STATUS FAULT <<<<<<<-----------------------------------------
	        
	        // Reading error signal from the motor drive
	        #MABSFault.Motor_Error := #ReadInputSignal.Fault;
	        
	        // FC_ConveyorStatusFault
	        #MABS_STATUS_FAULT(FaultActive := #MABSFault.Motor_Error,
	                           ResetFault := #SSR.ResetSystem,
	                           StatusRunning := #ReadMabsStatus.Running,
	                           FaultStatus => #ReadMabsStatus.Fault);
	        
	    END_REGION
	    
	    REGION Status ESTOP
	        
	        // ----------------------------------------->>>>>>> STATUS ESTOP <<<<<<<-----------------------------------------
	        
	        #AUTO_RESET(AckIN := #SSR.ResetSystem,
	                    Ack => #AutoReset);
	        
	        // EMERGENCY STOP ACTIVE --> STOP SYSTEM
	        IF #ReadInputSignal.EmergencyStop THEN
	            #ReadMabsStatus.Estop := TRUE;
	        END_IF;
	        // RESET --> EMERGENCY STOP
	        IF #AutoReset AND NOT #ReadInputSignal.EmergencyStop THEN
	            #ReadMabsStatus.Estop := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION Status Stop
	        
	        // ----------------------------------------->>>>>>> STATUS STOP <<<<<<<-----------------------------------------
	        
	        IF #SSR.StopSystem THEN
	            #ReadMabsStatus.Stop := TRUE;
	        END_IF;
	        IF #SSR.StartSystem OR #SSR.ResetSystem THEN
	            #ReadMabsStatus.Stop := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION Sensor Blockage
	        
	        // ----------------------------------------->>>>>>> STATUS BLOCKAGE <<<<<<<-------------------------------------
	        
	        // FB_SensorBlockage
	        // called as MIDB
	        
	        #MABS_SENSOR_BLOCKAGE.TON(IN := #ReadMabsStatus.ReadytoRun AND
	                                  #CROSS_SENSOR_FILTER.FilteredSensor,
	                                  PT := #ReadMabsParameter.SensorBlockageTime,
	                                  Q => #ReadMabsStatus.Blockage);
	        
	        // ==========================
	        // Sensor Blockage: HMI Alarm
	        // ==========================
	        // Sensor blockage alarm message is written to the first bit of the alarm word
	        // corresponding to the active line
	        
	        REGION alarm 
	            
	            // ==========================
	            // Sensor Blockage: HMI Alarm
	            // ==========================
	            // Sensor blockage alarm message is written to the alarm word
	            // corresponding to the active line
	            // Line A1
	            IF #Active.Line.A1 THEN
	                DB_Alarm."word".Line.A1.Conveyor[#MABS_ID].%X0 := #ReadMabsStatus.Blockage;
	            END_IF;
	            // Line B1
	            IF #Active.Line.B1 THEN
	               DB_Alarm."word".Line.B1.Conveyor[#MABS_ID].%X0 := #ReadMabsStatus.Blockage;
	            END_IF;
	            // Line C1
	            IF #Active.Line.C1 THEN
	               DB_Alarm."word".Line.C1.Conveyor[#MABS_ID].%X0 := #ReadMabsStatus.Blockage;
	            END_IF;
	            // Line D1
	            IF #Active.Line.D1 THEN
	                DB_Alarm."word".Line.D1.Conveyor[#MABS_ID].%X0 := #ReadMabsStatus.Blockage;
	            END_IF;
	            
	        END_REGION
	        
	    END_REGION
	    
	    REGION Visu Color
	        
	        // each and every status of the conveyor will be mentioned by different colors in HMI panel
	        
	        #VisuColor.%X8 := #ReadMabsStatus.Blockage;
	        #VisuColor.%X0 := #ReadMabsStatus.ON;
	        #VisuColor.%X1 := #ReadMabsStatus.ReadytoRun;
	        #VisuColor.%X2 := #ReadMabsStatus.Occupied;
	        #VisuColor.%X3 := #ReadMabsStatus.Running;
	        #VisuColor.%X4 := #ReadMabsStatus.Fault;
	        #VisuColor.%X5 := #ReadMabsStatus.Estop;
	        #VisuColor.%X6 := #ReadMabsStatus.Manual;
	        #VisuColor.%X7 := #ReadMabsStatus.Stop;
	        
	        // convert word to Interger value: 
	        // color will be depends on the status priority (integer value) 
	        // reference: Conveyor image in HMI screen -> property -> Apperance   
	        
	        // Line A1
	        IF #Active.Line.A1 THEN
	            DB_VisuColor.Line.A1.Conveyor[#MABS_ID] :=
	            WORD_TO_INT(#VisuColor);
	        END_IF;
	        // Line B1
	        IF #Active.Line.B1 THEN
	            DB_VisuColor.Line.B1.Conveyor[#MABS_ID] :=
	            WORD_TO_INT(#VisuColor);
	        END_IF;
	        // Line C1
	        IF #Active.Line.C1 THEN
	            DB_VisuColor.Line.C1.Conveyor[#MABS_ID] :=
	            WORD_TO_INT(#VisuColor);
	        END_IF;
	        // Line D1
	        IF #Active.Line.D1 THEN
	            DB_VisuColor.Line.D1.Conveyor[#MABS_ID] :=
	            WORD_TO_INT(#VisuColor);
	        END_IF;
	        
	    END_REGION
	    
	    REGION Global Status
	        
	        // write -> global status
	        // Line A1
	        IF #Active.Line.A1 THEN
	            DB_Global.Status.Line.A1.On[#MABS_ID] := #ReadMabsStatus.ON;
	            DB_Global.Status.Line.A1.ReadyToRun[#MABS_ID] := #ReadMabsStatus.ReadytoRun;
	            DB_Global.Status.Line.A1.Occupied[#MABS_ID] := #ReadMabsStatus.Occupied;
	            DB_Global.Status.Line.A1.Running[#MABS_ID] := #ReadMabsStatus.Running;
	            DB_Global.Status.Line.A1.Fault[#MABS_ID] := #ReadMabsStatus.Fault;
	            DB_Global.Status.Line.A1.Estop[#MABS_ID] := #ReadMabsStatus.Estop;
	            DB_Global.Status.Line.A1.Manual[#MABS_ID] := #ReadMabsStatus.Manual;
	            DB_Global.Status.Line.A1.Stop[#MABS_ID] := #ReadMabsStatus.Stop;
	            DB_Global.Status.Line.A1.Blockage[#MABS_ID] := #ReadMabsStatus.Blockage;
	        END_IF;
	        // Line B1
	        IF #Active.Line.B1 THEN
	            DB_Global.Status.Line.B1.On[#MABS_ID] := #ReadMabsStatus.ON;
	            DB_Global.Status.Line.B1.ReadyToRun[#MABS_ID] := #ReadMabsStatus.ReadytoRun;
	            DB_Global.Status.Line.B1.Occupied[#MABS_ID] := #ReadMabsStatus.Occupied;
	            DB_Global.Status.Line.B1.Running[#MABS_ID] := #ReadMabsStatus.Running;
	            DB_Global.Status.Line.B1.Fault[#MABS_ID] := #ReadMabsStatus.Fault;
	            DB_Global.Status.Line.B1.Estop[#MABS_ID] := #ReadMabsStatus.Estop;
	            DB_Global.Status.Line.B1.Manual[#MABS_ID] := #ReadMabsStatus.Manual;
	            DB_Global.Status.Line.B1.Stop[#MABS_ID] := #ReadMabsStatus.Stop;
	            DB_Global.Status.Line.B1.Blockage[#MABS_ID] := #ReadMabsStatus.Blockage;
	        END_IF;
	        // Line C1
	        IF #Active.Line.C1 THEN
	            DB_Global.Status.Line.C1.On[#MABS_ID] := #ReadMabsStatus.ON;
	            DB_Global.Status.Line.C1.ReadyToRun[#MABS_ID] := #ReadMabsStatus.ReadytoRun;
	            DB_Global.Status.Line.C1.Occupied[#MABS_ID] := #ReadMabsStatus.Occupied;
	            DB_Global.Status.Line.C1.Running[#MABS_ID] := #ReadMabsStatus.Running;
	            DB_Global.Status.Line.C1.Fault[#MABS_ID] := #ReadMabsStatus.Fault;
	            DB_Global.Status.Line.C1.Estop[#MABS_ID] := #ReadMabsStatus.Estop;
	            DB_Global.Status.Line.C1.Manual[#MABS_ID] := #ReadMabsStatus.Manual;
	            DB_Global.Status.Line.C1.Stop[#MABS_ID] := #ReadMabsStatus.Stop;
	            DB_Global.Status.Line.C1.Blockage[#MABS_ID] := #ReadMabsStatus.Blockage;
	        END_IF;
	        // Line D1
	        IF #Active.Line.D1 THEN
	            DB_Global.Status.Line.D1.On[#MABS_ID] := #ReadMabsStatus.ON;
	            DB_Global.Status.Line.D1.ReadyToRun[#MABS_ID] := #ReadMabsStatus.ReadytoRun;
	            DB_Global.Status.Line.D1.Occupied[#MABS_ID] := #ReadMabsStatus.Occupied;
	            DB_Global.Status.Line.D1.Running[#MABS_ID] := #ReadMabsStatus.Running;
	            DB_Global.Status.Line.D1.Fault[#MABS_ID] := #ReadMabsStatus.Fault;
	            DB_Global.Status.Line.D1.Estop[#MABS_ID] := #ReadMabsStatus.Estop;
	            DB_Global.Status.Line.D1.Manual[#MABS_ID] := #ReadMabsStatus.Manual;
	            DB_Global.Status.Line.D1.Stop[#MABS_ID] := #ReadMabsStatus.Stop;
	            DB_Global.Status.Line.D1.Blockage[#MABS_ID] := #ReadMabsStatus.Blockage;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	REGION Sorter sensor filter
	    
	    // cross sensor filter
	    #CROSS_SENSOR_FILTER(Sensor := #CrossSensor,
	                         SensorFilterTime := #ReadMabsParameter.SensorFilterTime,
	                         FilteredSensor=>#FilteredSensor);
	END_REGION
	
	REGION MABS LOGIC
	    
	    REGION rcv direction 
	        
	        IF NOT #FilteredSensor THEN
	            #Sort := #SortDir;
	        END_IF;
	        
	    END_REGION
	    
	    REGION MABS lib block
	        
	        #MABS_CONTROL(IBP_in  := #MABS_IBP_in,
	                      IBP_out := #MABS_IBP_out,
	                      MABS    := #"Cmd+Setpoint");
	        
	    END_REGION
	    
	    REGION run MABS wheels
	        
	        #"Cmd+Setpoint".Run_balls := #UpstreamRunning;
	        
	    END_REGION
	    
	    REGION Current position
	        
	        #CurrentPosition.left := #"Cmd+Setpoint".Left_Pos_reach;
	        #CurrentPosition.right := #"Cmd+Setpoint".Right_Pos_reach;
	        #CurrentPosition.straight := #"Cmd+Setpoint".Straight_Pos_reach;
	        
	    END_REGION
	    
	    REGION HOMING
	        
	        // ==========================================================================================================================
	        // Initial operation (home searching)
	        // ==================================
	        
	        // Home missing (if MABS could not receive any position in 't' duration)
	        #HomeCheckTimer.TON(IN := NOT #CurrentPosition.left AND
	                            NOT #CurrentPosition.right AND
	                            NOT #CurrentPosition.straight,
	                            PT := T#2s);
	        #Home :=
	        NOT #HomeCheckTimer.Q;
	        
	        // init HOME
	        IF NOT #Home AND NOT #ReadMabsStatus.Stop THEN
	            #"Cmd+Setpoint".Init := TRUE;
	        END_IF;
	        // RESET -> Init Home
	        IF #Home THEN
	            #"Cmd+Setpoint".Init := TRUE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION Parameters
	        
	        // change balls direction
	        #"Cmd+Setpoint".Dir_balls := #Setpoints.ChangeBallsDirection;
	        // balls speed
	        #"Cmd+Setpoint".Speed_balls := #Setpoints.Speed_balls;
	        // offset for straight
	        #"Cmd+Setpoint".Init_offset := #Setpoints.Init_offset;
	        
	    END_REGION
	    
	    REGION Sorting logic
	        
	        IF #ReadMabsStatus.ReadytoRun
	        THEN
	            
	            REGION Straight
	                
	                // ================================================== ^^^
	                
	                // sort straight - actual position: right
	                
	                IF #Sort.Straight AND
	                    NOT #CurrentPosition.straight AND
	                    #CurrentPosition.right AND
	                    NOT #CROSS_SENSOR_FILTER.FilteredSensor
	                THEN
	                    #"Cmd+Setpoint".Switch_right_to_st := TRUE;
	                ELSE
	                    #"Cmd+Setpoint".Switch_right_to_st := FALSE;
	                END_IF;
	                
	                // sort straight - actual position: left
	                
	                IF #Sort.Straight AND
	                    NOT #CurrentPosition.straight AND
	                    #CurrentPosition.left AND
	                    NOT #CROSS_SENSOR_FILTER.FilteredSensor
	                THEN
	                    #"Cmd+Setpoint".Switch_left_to_st := TRUE;
	                ELSE
	                    #"Cmd+Setpoint".Switch_left_to_st := FALSE;
	                END_IF;
	                
	            END_REGION
	            
	            REGION to Right
	                
	                // ================================================== >>>
	                
	                // sort right - actual position: straight/left
	                
	                IF #Sort.toRight AND
	                    NOT #CurrentPosition.right AND
	                    (#CurrentPosition.straight OR
	                    #CurrentPosition.left) AND
	                    NOT #CROSS_SENSOR_FILTER.FilteredSensor
	                THEN
	                    #"Cmd+Setpoint".Switch_right := TRUE;
	                ELSE
	                    #"Cmd+Setpoint".Switch_right := FALSE;
	                END_IF;
	                
	            END_REGION
	            
	            REGION to left
	                
	                // ================================================== <<<
	                
	                // sort left - actual position: straight/right
	                
	                IF #Sort.toLeft AND
	                    NOT #CurrentPosition.left AND
	                    (#CurrentPosition.straight OR
	                    #CurrentPosition.right) AND
	                    NOT #CROSS_SENSOR_FILTER.FilteredSensor
	                THEN
	                    #"Cmd+Setpoint".Switch_left := TRUE;
	                ELSE
	                    #"Cmd+Setpoint".Switch_left := FALSE;
	                END_IF;
	                
	            END_REGION
	            
	            // ============================================================================================================
	            
	        END_IF;
	        
	    END_REGION
	    
	   REGION reset error 
	        
	        // reset error
	       IF #ReadMabsStatus.Fault AND
	           #SSR.ResetSystem
	       THEN
	            #"Cmd+Setpoint".Reset_error := TRUE;
	        ELSE
	            #"Cmd+Setpoint".Reset_error := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	    REGION stop function
	        
	        // stop if not ready
	        IF NOT #ReadMabsStatus.ReadytoRun AND NOT #ReadMabsStatus.Manual
	        THEN
	            #"Cmd+Setpoint".Switch_left := FALSE;
	            #"Cmd+Setpoint".Switch_right := FALSE;
	            #"Cmd+Setpoint".Switch_right_to_st := FALSE;
	            #"Cmd+Setpoint".Switch_left_to_st := FALSE;
	        END_IF;
	        
	    END_REGION
	    
	END_REGION
	
	
	
END_FUNCTION_BLOCK
END_NAMESPACE

